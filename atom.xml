<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://www.luoboyu.com</id>
    <title>吴超武个人博客</title>
    <updated>2019-09-26T09:21:07.050Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://www.luoboyu.com"/>
    <link rel="self" href="https://www.luoboyu.com/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://www.luoboyu.com/images/avatar.png</logo>
    <icon>https://www.luoboyu.com/favicon.ico</icon>
    <rights>All rights reserved 2019, 吴超武个人博客</rights>
    <entry>
        <title type="html"><![CDATA[kubernetes  常用的命令]]></title>
        <id>https://www.luoboyu.com/post/kubernetes-chang-yong-de-ming-ling</id>
        <link href="https://www.luoboyu.com/post/kubernetes-chang-yong-de-ming-ling">
        </link>
        <updated>2018-11-30T08:53:45.000Z</updated>
        <summary type="html"><![CDATA[<p>kubectl是Kubernetes集群的命令行工具，通过kubectl能够对集群本身进行管理，并能够在集群上进行容器化应用的安装部署<br>
kubelet：负责pod对应的容器创建、启停等任务，同时与master 节点密切协作，实现集群管理的基本功能<br>
kube-proxy:实现kubernetes Service 的通信与负载均衡机制的重要组件</p>
]]></summary>
        <content type="html"><![CDATA[<p>kubectl是Kubernetes集群的命令行工具，通过kubectl能够对集群本身进行管理，并能够在集群上进行容器化应用的安装部署<br>
kubelet：负责pod对应的容器创建、启停等任务，同时与master 节点密切协作，实现集群管理的基本功能<br>
kube-proxy:实现kubernetes Service 的通信与负载均衡机制的重要组件</p>
<!-- more -->
<h2 id="11-common-commands">1.1 Common Commands</h2>
<table>
<thead>
<tr>
<th>Name</th>
<th>Command</th>
</tr>
</thead>
<tbody>
<tr>
<td>Run curl test temporarily</td>
<td><code>kubectl run --rm mytest --image=yauritux/busybox-curl -it</code></td>
</tr>
<tr>
<td>Run wget test temporarily</td>
<td><code>kubectl run --rm mytest --image=busybox -it</code></td>
</tr>
<tr>
<td>Run nginx deployment with 2 replicas</td>
<td><code>kubectl run my-nginx --image=nginx --replicas=2 --port=80</code></td>
</tr>
<tr>
<td>Run nginx pod and expose it</td>
<td><code>kubectl run my-nginx --restart=Never --image=nginx --port=80 --expose</code></td>
</tr>
<tr>
<td>Run nginx deployment and expose it</td>
<td><code>kubectl run my-nginx --image=nginx --port=80 --expose</code></td>
</tr>
<tr>
<td>Set namespace preference</td>
<td><code>kubectl config set-context &lt;context_name&gt; --namespace=&lt;ns_name&gt;</code></td>
</tr>
<tr>
<td>List pods with nodes info</td>
<td><code>kubectl get pod -o wide</code></td>
</tr>
<tr>
<td>List everything</td>
<td><code>kubectl get all --all-namespaces</code></td>
</tr>
<tr>
<td>Get all services</td>
<td><code>kubectl get service --all-namespaces</code></td>
</tr>
<tr>
<td>Get all deployments</td>
<td><code>kubectl get deployments --all-namespaces</code></td>
</tr>
<tr>
<td>Show nodes with labels</td>
<td><code>kubectl get nodes --show-labels</code></td>
</tr>
<tr>
<td>Get resources with json output</td>
<td><code>kubectl get pods --all-namespaces -o json</code></td>
</tr>
<tr>
<td>Validate yaml file with dry run</td>
<td><code>kubectl create --dry-run --validate -f pod-dummy.yaml</code></td>
</tr>
<tr>
<td>Start a temporary pod for testing</td>
<td><code>kubectl run --rm -i -t --image=alpine test-$RANDOM -- sh</code></td>
</tr>
<tr>
<td>kubectl run shell command</td>
<td><code>kubectl exec -it mytest -- ls -l /etc/hosts</code></td>
</tr>
<tr>
<td>Get system conf via configmap</td>
<td><code>kubectl -n kube-system get cm kubeadm-config -o yaml</code></td>
</tr>
<tr>
<td>Get deployment yaml</td>
<td><code>kubectl -n denny-websites get deployment mysql -o yaml</code></td>
</tr>
<tr>
<td>Explain resource</td>
<td><code>kubectl explain pods</code>, <code>kubectl explain svc</code></td>
</tr>
<tr>
<td>Watch pods</td>
<td><code>kubectl get pods -n wordpress --watch</code></td>
</tr>
<tr>
<td>Query healthcheck endpoint</td>
<td><code>curl -L http://127.0.0.1:10250/healthz</code></td>
</tr>
<tr>
<td>Open a bash terminal in a pod</td>
<td><code>kubectl exec -it storage sh</code></td>
</tr>
<tr>
<td>Check pod environment variables</td>
<td><code>kubectl exec redis-master-ft9ex env</code></td>
</tr>
<tr>
<td>Enable kubectl shell autocompletion</td>
<td><code>echo &quot;source &lt;(kubectl completion bash)&quot; &gt;&gt;~/.bashrc</code>, and reload</td>
</tr>
<tr>
<td>Use minikube dockerd in your laptop</td>
<td><code>eval $(minikube docker-env)</code>, No need to push docker hub any more</td>
</tr>
<tr>
<td>Kubectl apply a folder of yaml files</td>
<td><code>kubectl apply -R -f .</code></td>
</tr>
<tr>
<td>Get services sorted by name</td>
<td>kubectl get services –sort-by=.metadata.name</td>
</tr>
<tr>
<td>Get pods sorted by restart count</td>
<td>kubectl get pods –sort-by=’.status.containerStatuses[0].restartCount’</td>
</tr>
<tr>
<td>List pods and images</td>
<td>kubectl get pods -o=’custom-columns=PODS:.metadata.name,Images:.spec.containers[*].image’</td>
</tr>
<tr>
<td>List all container images</td>
<td><a href="https://github.com/dennyzhang/cheatsheet-kubernetes-A4/blob/master/list-all-images.sh#L14-L17">list-all-images.sh</a></td>
</tr>
<tr>
<td>kubeconfig skip tls verification</td>
<td><a href="https://github.com/dennyzhang/cheatsheet-kubernetes-A4/blob/master/skip-tls-verify.md">skip-tls-verify.md</a></td>
</tr>
<tr>
<td><a href="https://kubernetes.io/docs/tasks/tools/install-kubectl/">Ubuntu install kubectl</a></td>
<td>=”deb https://apt.kubernetes.io/ kubernetes-xenial main”=</td>
</tr>
<tr>
<td>Reference</td>
<td><a href="https://github.com/kubernetes/kubernetes/tags">GitHub: kubernetes releases</a></td>
</tr>
<tr>
<td>Reference</td>
<td><a href="https://cheatsheet.dennyzhang.com/cheatsheet-minikube-A4">minikube cheatsheet</a>, <a href="https://cheatsheet.dennyzhang.com/cheatsheet-docker-A4">docker cheatsheet</a>, <a href="https://cheatsheet.dennyzhang.com/cheatsheet-openshift-A4">OpenShift CheatSheet</a></td>
</tr>
</tbody>
</table>
<h2 id="12-check-performance">1.2 Check Performance</h2>
<table>
<thead>
<tr>
<th>Name</th>
<th>Command</th>
</tr>
</thead>
<tbody>
<tr>
<td>Get node resource usage</td>
<td><code>kubectl top node</code></td>
</tr>
<tr>
<td>Get pod resource usage</td>
<td><code>kubectl top pod</code></td>
</tr>
<tr>
<td>Get resource usage for a given pod</td>
<td><code>kubectl top &lt;podname&gt; --containers</code></td>
</tr>
<tr>
<td>List resource utilization for all containers</td>
<td><code>kubectl top pod --all-namespaces --containers=true</code></td>
</tr>
</tbody>
</table>
<h2 id="13-resources-deletion">1.3 Resources Deletion</h2>
<table>
<thead>
<tr>
<th>Name</th>
<th>Command</th>
</tr>
</thead>
<tbody>
<tr>
<td>Delete pod</td>
<td><code>kubectl delete pod/&lt;pod-name&gt; -n &lt;my-namespace&gt;</code></td>
</tr>
<tr>
<td>Delete pod by force</td>
<td><code>kubectl delete pod/&lt;pod-name&gt; --grace-period=0 --force</code></td>
</tr>
<tr>
<td>Delete pods by labels</td>
<td><code>kubectl delete pod -l env=test</code></td>
</tr>
<tr>
<td>Delete deployments by labels</td>
<td><code>kubectl delete deployment -l app=wordpress</code></td>
</tr>
<tr>
<td>Delete all resources filtered by labels</td>
<td><code>kubectl delete pods,services -l name=myLabel</code></td>
</tr>
<tr>
<td>Delete resources under a namespace</td>
<td><code>kubectl -n my-ns delete po,svc --all</code></td>
</tr>
<tr>
<td>Delete persist volumes by labels</td>
<td><code>kubectl delete pvc -l app=wordpress</code></td>
</tr>
<tr>
<td>Delete state fulset only (not pods)</td>
<td><code>kubectl delete sts/&lt;stateful_set_name&gt; --cascade=false</code></td>
</tr>
</tbody>
</table>
<h2 id="14-log-conf-files">1.4 Log &amp; Conf Files</h2>
<table>
<thead>
<tr>
<th>Name</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>Config folder</td>
<td><code>/etc/kubernetes/</code></td>
</tr>
<tr>
<td>Certificate files</td>
<td><code>/etc/kubernetes/pki/</code></td>
</tr>
<tr>
<td>Credentials to API server</td>
<td><code>/etc/kubernetes/kubelet.conf</code></td>
</tr>
<tr>
<td>Superuser credentials</td>
<td><code>/etc/kubernetes/admin.conf</code></td>
</tr>
<tr>
<td>kubectl config file</td>
<td><code>~/.kube/config</code></td>
</tr>
<tr>
<td>Kubernets working dir</td>
<td><code>/var/lib/kubelet/</code></td>
</tr>
<tr>
<td>Docker working dir</td>
<td><code>/var/lib/docker/</code>, <code>/var/log/containers/</code></td>
</tr>
<tr>
<td>Etcd working dir</td>
<td><code>/var/lib/etcd/</code></td>
</tr>
<tr>
<td>Network cni</td>
<td><code>/etc/cni/net.d/</code></td>
</tr>
<tr>
<td>Log files</td>
<td><code>/var/log/pods/</code></td>
</tr>
<tr>
<td>log in worker node</td>
<td><code>/var/log/kubelet.log</code>, <code>/var/log/kube-proxy.log</code></td>
</tr>
<tr>
<td>log in master node</td>
<td><code>kube-apiserver.log</code>, <code>kube-scheduler.log</code>, <code>kube-controller-manager.log</code></td>
</tr>
<tr>
<td>Env</td>
<td><code>/etc/systemd/system/kubelet.service.d/10-kubeadm.conf</code></td>
</tr>
<tr>
<td>Env</td>
<td>export KUBECONFIG=/etc/kubernetes/admin.conf</td>
</tr>
</tbody>
</table>
<h2 id="15-pod">1.5 Pod</h2>
<table>
<thead>
<tr>
<th>Name</th>
<th>Command</th>
</tr>
</thead>
<tbody>
<tr>
<td>List all pods</td>
<td><code>kubectl get pods</code></td>
</tr>
<tr>
<td>List pods for all namespace</td>
<td><code>kubectl get pods -all-namespaces</code></td>
</tr>
<tr>
<td>List all critical pods</td>
<td><code>kubectl get -n kube-system pods -a</code></td>
</tr>
<tr>
<td>List pods with more info</td>
<td><code>kubectl get pod -o wide</code>, <code>kubectl get pod/&lt;pod-name&gt; -o yaml</code></td>
</tr>
<tr>
<td>Get pod info</td>
<td><code>kubectl describe pod/srv-mysql-server</code></td>
</tr>
<tr>
<td>List all pods with labels</td>
<td><code>kubectl get pods --show-labels</code></td>
</tr>
<tr>
<td><a href="https://github.com/kubernetes/kubernetes/issues/49387">List all unhealthy pods</a></td>
<td>kubectl get pods –field-selector=status.phase!=Running –all-namespaces</td>
</tr>
<tr>
<td>List running pods</td>
<td>kubectl get pods –field-selector=status.phase=Running</td>
</tr>
<tr>
<td>Get Pod initContainer status</td>
<td><code>kubectl get pod --template '{{.status.initContainerStatuses}}' &lt;pod-name&gt;</code></td>
</tr>
<tr>
<td>kubectl run command</td>
<td>kubectl exec -it -n “<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>s</mi><mi mathvariant="normal">”</mi><mi mathvariant="normal">“</mi></mrow><annotation encoding="application/x-tex">ns” “</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">s</span><span class="mord">”</span><span class="mord">“</span></span></span></span>podname” – sh -c “echo $msg &gt;&gt;/dev/err.log”</td>
</tr>
<tr>
<td>Watch pods</td>
<td><code>kubectl get pods -n wordpress --watch</code></td>
</tr>
<tr>
<td>Get pod by selector</td>
<td>kubectl get pods –selector=”app=syslog” -o jsonpath=’{.items[*].metadata.name}’</td>
</tr>
<tr>
<td>List pods and images</td>
<td>kubectl get pods -o=’custom-columns=PODS:.metadata.name,Images:.spec.containers[*].image’</td>
</tr>
<tr>
<td>List pods and containers</td>
<td>-o=’custom-columns=PODS:.metadata.name,CONTAINERS:.spec.containers[*].name’</td>
</tr>
<tr>
<td>Reference</td>
<td><a href="https://cheatsheet.dennyzhang.com/kubernetes-yaml-templates">Link: kubernetes yaml templates</a></td>
</tr>
</tbody>
</table>
<h2 id="16-label-annontation">1.6 Label &amp; Annontation</h2>
<table>
<thead>
<tr>
<th>Name</th>
<th>Command</th>
</tr>
</thead>
<tbody>
<tr>
<td>Filter pods by label</td>
<td><code>kubectl get pods -l owner=denny</code></td>
</tr>
<tr>
<td>Manually add label to a pod</td>
<td><code>kubectl label pods dummy-input owner=denny</code></td>
</tr>
<tr>
<td>Remove label</td>
<td><code>kubectl label pods dummy-input owner-</code></td>
</tr>
<tr>
<td>Manually add annonation to a pod</td>
<td><code>kubectl annotate pods dummy-input my-url=https://dennyzhang.com</code></td>
</tr>
</tbody>
</table>
<h2 id="17-deployment-scale">1.7 Deployment &amp; Scale</h2>
<table>
<thead>
<tr>
<th>Name</th>
<th>Command</th>
</tr>
</thead>
<tbody>
<tr>
<td>Scale out</td>
<td><code>kubectl scale --replicas=3 deployment/nginx-app</code></td>
</tr>
<tr>
<td>online rolling upgrade</td>
<td><code>kubectl rollout app-v1 app-v2 --image=img:v2</code></td>
</tr>
<tr>
<td>Roll backup</td>
<td><code>kubectl rollout app-v1 app-v2 --rollback</code></td>
</tr>
<tr>
<td>List rollout</td>
<td><code>kubectl get rs</code></td>
</tr>
<tr>
<td>Check update status</td>
<td><code>kubectl rollout status deployment/nginx-app</code></td>
</tr>
<tr>
<td>Check update history</td>
<td><code>kubectl rollout history deployment/nginx-app</code></td>
</tr>
<tr>
<td>Pause/Resume</td>
<td><code>kubectl rollout pause deployment/nginx-deployment</code>, <code>resume</code></td>
</tr>
<tr>
<td>Rollback to previous version</td>
<td><code>kubectl rollout undo deployment/nginx-deployment</code></td>
</tr>
<tr>
<td>Reference</td>
<td><a href="https://cheatsheet.dennyzhang.com/kubernetes-yaml-templates">Link: kubernetes yaml templates</a>, <a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/#pausing-and-resuming-a-deployment">Link: Pausing and Resuming a Deployment</a></td>
</tr>
</tbody>
</table>
<h2 id="18-quota-limits-resource">1.8 Quota &amp; Limits &amp; Resource</h2>
<table>
<thead>
<tr>
<th>Name</th>
<th>Command</th>
</tr>
</thead>
<tbody>
<tr>
<td>List Resource Quota</td>
<td><code>kubectl get resourcequota</code></td>
</tr>
<tr>
<td>List Limit Range</td>
<td><code>kubectl get limitrange</code></td>
</tr>
<tr>
<td>Customize resource definition</td>
<td><code>kubectl set resources deployment nginx -c=nginx --limits=cpu=200m</code></td>
</tr>
<tr>
<td>Customize resource definition</td>
<td><code>kubectl set resources deployment nginx -c=nginx --limits=memory=512Mi</code></td>
</tr>
<tr>
<td>Reference</td>
<td><a href="https://cheatsheet.dennyzhang.com/kubernetes-yaml-templates">Link: kubernetes yaml templates</a></td>
</tr>
</tbody>
</table>
<h2 id="19-service">1.9 Service</h2>
<table>
<thead>
<tr>
<th>Name</th>
<th>Command</th>
</tr>
</thead>
<tbody>
<tr>
<td>List all services</td>
<td><code>kubectl get services</code></td>
</tr>
<tr>
<td>List service endpoints</td>
<td><code>kubectl get endpoints</code></td>
</tr>
<tr>
<td>Get service detail</td>
<td><code>kubectl get service nginx-service -o yaml</code></td>
</tr>
<tr>
<td>Get service cluster ip</td>
<td>kubectl get service nginx-service -o go-template=’{{.spec.clusterIP}}’</td>
</tr>
<tr>
<td>Get service cluster port</td>
<td>kubectl get service nginx-service -o go-template=’{{(index .spec.ports 0).port}}’</td>
</tr>
<tr>
<td>Expose deployment as lb service</td>
<td><code>kubectl expose deployment/my-app --type=LoadBalancer --name=my-service</code></td>
</tr>
<tr>
<td>Expose service as lb service</td>
<td><code>kubectl expose service/wordpress-1-svc --type=LoadBalancer --name=ns1</code></td>
</tr>
<tr>
<td>Reference</td>
<td><a href="https://cheatsheet.dennyzhang.com/kubernetes-yaml-templates">Link: kubernetes yaml templates</a></td>
</tr>
</tbody>
</table>
<h2 id="110-secrets">1.10 Secrets</h2>
<table>
<thead>
<tr>
<th>Name</th>
<th>Command</th>
</tr>
</thead>
<tbody>
<tr>
<td>List secrets</td>
<td><code>kubectl get secrets --all-namespaces</code></td>
</tr>
<tr>
<td>Generate secret</td>
<td><code>echo -n 'mypasswd'=, then redirect to =base64 --decode</code></td>
</tr>
<tr>
<td>Get secret</td>
<td><code>kubectl get secret denny-cluster-kubeconfig</code></td>
</tr>
<tr>
<td>Get a specific field of a secret</td>
<td>kubectl get secret denny-cluster-kubeconfig -o jsonpath=”{.data.value}”</td>
</tr>
<tr>
<td>Create secret from cfg file</td>
<td>kubectl create secret generic db-user-pass –from-file=./username.txt</td>
</tr>
<tr>
<td>Reference</td>
<td><a href="https://cheatsheet.dennyzhang.com/kubernetes-yaml-templates">Link: kubernetes yaml templates</a>, <a href="https://kubernetes.io/docs/concepts/configuration/secret/">Link: Secrets</a></td>
</tr>
</tbody>
</table>
<h2 id="111-statefulset">1.11 StatefulSet</h2>
<table>
<thead>
<tr>
<th>Name</th>
<th>Command</th>
</tr>
</thead>
<tbody>
<tr>
<td>List statefulset</td>
<td><code>kubectl get sts</code></td>
</tr>
<tr>
<td>Delete statefulset only (not pods)</td>
<td><code>kubectl delete sts/&lt;stateful_set_name&gt; --cascade=false</code></td>
</tr>
<tr>
<td>Scale statefulset</td>
<td><code>kubectl scale sts/&lt;stateful_set_name&gt; --replicas=5</code></td>
</tr>
<tr>
<td>Reference</td>
<td><a href="https://cheatsheet.dennyzhang.com/kubernetes-yaml-templates">Link: kubernetes yaml templates</a></td>
</tr>
</tbody>
</table>
<h2 id="112-volumes-volume-claims">1.12 Volumes &amp; Volume Claims</h2>
<table>
<thead>
<tr>
<th>Name</th>
<th>Command</th>
</tr>
</thead>
<tbody>
<tr>
<td>List storage class</td>
<td><code>kubectl get storageclass</code></td>
</tr>
<tr>
<td>Check the mounted volumes</td>
<td><code>kubectl exec storage ls /data</code></td>
</tr>
<tr>
<td>Check persist volume</td>
<td><code>kubectl describe pv/pv0001</code></td>
</tr>
<tr>
<td>Copy local file to pod</td>
<td><code>kubectl cp /tmp/my &lt;some-namespace&gt;/&lt;some-pod&gt;:/tmp/server</code></td>
</tr>
<tr>
<td>Copy pod file to local</td>
<td><code>kubectl cp &lt;some-namespace&gt;/&lt;some-pod&gt;:/tmp/server /tmp/my</code></td>
</tr>
<tr>
<td>Reference</td>
<td><a href="https://cheatsheet.dennyzhang.com/kubernetes-yaml-templates">Link: kubernetes yaml templates</a></td>
</tr>
</tbody>
</table>
<h2 id="113-events-metrics">1.13 Events &amp; Metrics</h2>
<table>
<thead>
<tr>
<th>Name</th>
<th>Command</th>
</tr>
</thead>
<tbody>
<tr>
<td>View all events</td>
<td><code>kubectl get events --all-namespaces</code></td>
</tr>
<tr>
<td>List Events sorted by timestamp</td>
<td>kubectl get events –sort-by=.metadata.creationTimestamp</td>
</tr>
</tbody>
</table>
<h2 id="114-node-maintenance">1.14 Node Maintenance</h2>
<table>
<thead>
<tr>
<th>Name</th>
<th>Command</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mark node as unschedulable</td>
<td><code>kubectl cordon $NDOE_NAME</code></td>
</tr>
<tr>
<td>Mark node as schedulable</td>
<td><code>kubectl uncordon $NDOE_NAME</code></td>
</tr>
<tr>
<td>Drain node in preparation for maintenance</td>
<td><code>kubectl drain $NODE_NAME</code></td>
</tr>
</tbody>
</table>
<h2 id="115-namespace-security">1.15 Namespace &amp; Security</h2>
<table>
<thead>
<tr>
<th>Name</th>
<th>Command</th>
</tr>
</thead>
<tbody>
<tr>
<td>List authenticated contexts</td>
<td><code>kubectl config get-contexts</code>, <code>~/.kube/config</code></td>
</tr>
<tr>
<td>Set namespace preference</td>
<td><code>kubectl config set-context &lt;context_name&gt; --namespace=&lt;ns_name&gt;</code></td>
</tr>
<tr>
<td>Load context from config file</td>
<td><code>kubectl get cs --kubeconfig kube_config.yml</code></td>
</tr>
<tr>
<td>Switch context</td>
<td><code>kubectl config use-context &lt;cluster-name&gt;</code></td>
</tr>
<tr>
<td>Delete the specified context</td>
<td><code>kubectl config delete-context &lt;cluster-name&gt;</code></td>
</tr>
<tr>
<td>List all namespaces defined</td>
<td><code>kubectl get namespaces</code></td>
</tr>
<tr>
<td>List certificates</td>
<td><code>kubectl get csr</code></td>
</tr>
<tr>
<td>Reference</td>
<td><a href="https://cheatsheet.dennyzhang.com/kubernetes-yaml-templates">Link: kubernetes yaml templates</a></td>
</tr>
</tbody>
</table>
<h2 id="116-network">1.16 Network</h2>
<table>
<thead>
<tr>
<th>Name</th>
<th>Command</th>
</tr>
</thead>
<tbody>
<tr>
<td>Temporarily add a port-forwarding</td>
<td><code>kubectl port-forward redis-134 6379:6379</code></td>
</tr>
<tr>
<td>Add port-forwaring for deployment</td>
<td><code>kubectl port-forward deployment/redis-master 6379:6379</code></td>
</tr>
<tr>
<td>Add port-forwaring for replicaset</td>
<td><code>kubectl port-forward rs/redis-master 6379:6379</code></td>
</tr>
<tr>
<td>Add port-forwaring for service</td>
<td><code>kubectl port-forward svc/redis-master 6379:6379</code></td>
</tr>
<tr>
<td>Get network policy</td>
<td><code>kubectl get NetworkPolicy</code></td>
</tr>
</tbody>
</table>
<h2 id="117-patch">1.17 Patch</h2>
<table>
<thead>
<tr>
<th>Name</th>
<th>Summary</th>
</tr>
</thead>
<tbody>
<tr>
<td>Patch service to loadbalancer</td>
<td>=kubectl patch svc $svc_name -p ‘{“spec”: {“type”: “LoadBalancer”}}’=</td>
</tr>
</tbody>
</table>
<h2 id="118-extenstions">1.18 Extenstions</h2>
<table>
<thead>
<tr>
<th>Name</th>
<th>Summary</th>
</tr>
</thead>
<tbody>
<tr>
<td>List api group</td>
<td><code>kubectl api-versions</code></td>
</tr>
<tr>
<td>List all CRD</td>
<td><code>kubectl get crd</code></td>
</tr>
<tr>
<td>List storageclass</td>
<td><code>kubectl get storageclass</code></td>
</tr>
<tr>
<td>List all supported resources</td>
<td><code>kubectl api-resources</code></td>
</tr>
</tbody>
</table>
<h3 id="1191-services-on-master-nodes">1.19.1 Services on Master Nodes</h3>
<table>
<thead>
<tr>
<th>Name</th>
<th>Summary</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/kubernetes/kubernetes/tree/master/cmd/kube-apiserver">kube-apiserver</a></td>
<td>exposes the Kubernetes API from master nodes</td>
</tr>
<tr>
<td><a href="https://coreos.com/etcd/">etcd</a></td>
<td>reliable data store for all k8s cluster data</td>
</tr>
<tr>
<td><a href="https://github.com/kubernetes/kubernetes/tree/master/cmd/kube-scheduler">kube-scheduler</a></td>
<td>schedule pods to run on selected nodes</td>
</tr>
<tr>
<td><a href="https://github.com/kubernetes/kubernetes/tree/master/cmd/kube-controller-manager">kube-controller-manager</a></td>
<td>node controller, replication controller, endpoints controller, and service account &amp; token controllers</td>
</tr>
</tbody>
</table>
<h3 id="1192-services-on-worker-nodes">1.19.2 Services on Worker Nodes</h3>
<table>
<thead>
<tr>
<th>Name</th>
<th>Summary</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/kubernetes/kubernetes/tree/master/cmd/kubelet">kubelet</a></td>
<td>makes sure that containers are running in a pod</td>
</tr>
<tr>
<td><a href="https://github.com/kubernetes/kubernetes/tree/master/cmd/kube-proxy">kube-proxy</a></td>
<td>perform connection forwarding</td>
</tr>
<tr>
<td><a href="https://github.com/docker/engine">Container Runtime</a></td>
<td>Kubernetes supported runtimes: Docker, rkt, runc and any <a href="https://github.com/opencontainers/runtime-spec">OCI runtime-spec</a> implementation.</td>
</tr>
</tbody>
</table>
<h3 id="1193-addons-pods-and-services-that-implement-cluster-features">1.19.3 Addons: pods and services that implement cluster features</h3>
<table>
<thead>
<tr>
<th>Name</th>
<th>Summary</th>
</tr>
</thead>
<tbody>
<tr>
<td>DNS</td>
<td>serves DNS records for Kubernetes services</td>
</tr>
<tr>
<td>Web UI</td>
<td>a general purpose, web-based UI for Kubernetes clusters</td>
</tr>
<tr>
<td>Container Resource Monitoring</td>
<td>collect, store and serve container metrics</td>
</tr>
<tr>
<td>Cluster-level Logging</td>
<td>save container logs to a central log store with search/browsing interface</td>
</tr>
</tbody>
</table>
<h3 id="1194-tools">1.19.4 Tools</h3>
<table>
<thead>
<tr>
<th>Name</th>
<th>Summary</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://github.com/kubernetes/kubernetes/tree/master/cmd/kubectl">kubectl</a></td>
<td>the command line util to talk to k8s cluster</td>
</tr>
<tr>
<td><a href="https://github.com/kubernetes/kubernetes/tree/master/cmd/kubeadm">kubeadm</a></td>
<td>the command to bootstrap the cluster</td>
</tr>
<tr>
<td><a href="https://kubernetes.io/docs/reference/setup-tools/kubefed/kubefed/">kubefed</a></td>
<td>the command line to control a Kubernetes Cluster Federation</td>
</tr>
<tr>
<td>Kubernetes Components</td>
<td><a href="https://kubernetes.io/docs/concepts/overview/components/">Link: Kubernetes Components</a></td>
</tr>
</tbody>
</table>
<h2 id="120-more-resources">1.20 More Resources</h2>
<p>https://kubernetes.io/docs/reference/kubectl/cheatsheet/</p>
<p>https://codefresh.io/kubernetes-guides/kubernetes-cheat-sheet/</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Minikube 使用]]></title>
        <id>https://www.luoboyu.com/post/hello-gridea</id>
        <link href="https://www.luoboyu.com/post/hello-gridea">
        </link>
        <updated>2018-10-10T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>背景介绍<br>
Minikube是什么？</p>
<p><a href="https://kubernetes.io/docs/tasks/tools/install-minikube/">Minikube</a>是一个能够在虚拟机中运行单节点Kubernetes集群的工具，它使得开发者可以在本地环境中进行开发和调试Kubernetes。推荐阿里封装的<a href="https://github.com/AliyunContainerService/minikube">minikube</a></p>
]]></summary>
        <content type="html"><![CDATA[<p>背景介绍<br>
Minikube是什么？</p>
<p><a href="https://kubernetes.io/docs/tasks/tools/install-minikube/">Minikube</a>是一个能够在虚拟机中运行单节点Kubernetes集群的工具，它使得开发者可以在本地环境中进行开发和调试Kubernetes。推荐阿里封装的<a href="https://github.com/AliyunContainerService/minikube">minikube</a></p>
<!-- more -->
<p>Kubernetes又是什么？</p>
<p>Kubernetes是一个用来自动部署、伸缩、和管理容器化应用的开源系统。<br>
容器又是什么？</p>
<p>容器指的是运用虚拟化技术将不同应用和其所需的运行环境进行隔离的进程，其中Docker是最著名的开源容器软件。</p>
<p><strong>容器又是什么？</strong></p>
<p>容器指的是运用虚拟化技术将不同应用和其所需的运行环境进行隔离的进程，其中<a href="https://www.docker.com/what-docker#/overview">Docker</a>是最著名的开源容器软件。</p>
<ul>
<li>我有几个项目使用的不同Node.js版本，开发调试需要进行切换很不方便。——容器的虚拟运行环境可以解决</li>
<li>每次部署都要重新安装依赖，而且不同环境依赖安装后可能出现问题。——打包成镜像，无需再安装依赖，秒级启动。</li>
<li>我想创建几个同样的进程做负载均衡/高可用。——用Kubernetes创建容器副本。</li>
<li>我希望我的进程在生产环境中挂掉或者被误杀之后自动重新启动。——用Kubernetes的自愈功能操作容器。</li>
<li>根据不同机器的资源使用情况来分配进程。——用Kubernetes来调度容器。<br>
…</li>
</ul>
<h2 id="hyper-vwindows8以上的系统默认已安装">Hyper-V（Windows8以上的系统默认已安装）</h2>
<p>首先<code>minikube start</code>会默认使用VirtualBox，但是我们用的是Hyper-V，所以需要加参数指定：</p>
<pre><code>minikube start --vm-driver=hyperv
</code></pre>
<p>还记得我们之前创建的虚拟网络交换机吗？这时候就需要用到它了。</p>
<pre><code>minikube start --vm-driver=hyperv --hyperv-virtual-switch=k8svswitch
</code></pre>
<p>默认不显示错误信息，为了方便排查启动中的问题，我们还是开启日志输出。</p>
<pre><code>minikube start --vm-driver=hyperv --hyperv-virtual-switch=k8svswitch --v=3 --alsologtostderr
</code></pre>
<p>默认需要2048Mb内存，如果不够我们需要<code>--memory 1024</code>指定一下更小的空间，当然我的机器10Gb的内存不可能不够，这个参数省略了~</p>
<p><strong>管理员模式打开命令行</strong>，执行上面那条<code>minikube start ...</code>开头的命令。</p>
<p>执行完成之后输入<code>kubectl cluster-info dump</code>，看到集群的大量详细信息表示安装成功~</p>
<p>如果按照以上步骤仍不成功，可以参考国外网友的一篇文章</p>
<p><a href="https://gibmirfred.de/2017/02/run-k8s-minikube-on-windows-10-with-hyper-v/">《Run k8s minikube on Windows 10 with Hyper-V》https://gibmirfred.de/2017/02/run-k8s-minikube-on-windows-10-with-hyper-v/</a></p>
<p>1.1 MINIKUBE BASIC<br>
Name	Command<br>
minikube lifecycle	minikube delete, minikube start, minikube status, Link: minikube<br>
Get minikube version	minikube version, Link: all minikube releases<br>
mac install minikube	brew cask install minikube, brew cask reinstall minikube<br>
Start minikube with different machine flavor	minikube start --memory 5120 --cpus=4<br>
Start minikube with a specific k8s version	minikube start --kubernetes-version v1.11.0<br>
Start minikube with more customizations	minikube start –kubernetes-version v1.11.0 –feature-gates=AdvancedAuditing=true<br>
SSH to minikube vm	minikube ssh, ssh -i ~/.minikube/machines/minikube/id_rsa docker@192.168.99.100<br>
Your local docker to use minikube dockerd	eval $(minikube docker-env), Then no need for docker push<br>
Minikube check latest version	minikube update-check<br>
Reference	Minikube CheatSheet, Kubernetes kind CheatSheet<br>
Reference	Kubectl CheatSheet, Kubernetes Yaml<br>
1.2 CHECK STATUS<br>
Name	Command<br>
Get minikube version	minikube version, Link: all minikube releases<br>
Get cluster info	kubectl cluster-info<br>
Get service info	minikube service <srv-name><br>
Get dashboard	minikube dashboard<br>
Get ip	minikube ip<br>
Get minikube log	minikube logs<br>
List addons	minikube addons list<br>
1.3 MINIKUBE FOLDERS<br>
Name	Command<br>
Mount host OS’s folder to minikube VM	minikube mount /host-mount-path:/vm-mount-path<br>
Folder of k8s.io/minikube-hostpath provisioner	/tmp/hostpath-provisioner, /tmp/hostpath_pv<br>
Mount host OS’s folder to minikube VM	minikube mount /host-mount-path:/vm-mount-path<br>
Critical minikube folder	/var/lib/localkube, /var/lib/docker, /data<br>
Check minikube config in your host OS desktop	~/.minikube/machines/minikube/config.json<br>
Minikube conf in local env	~/.minikube, ~/.kube<br>
1.4 MINIKUBE ADVANCED<br>
Name	Command<br>
Install addon after creating minikube env	minikube addons enable heapster, kubectl top node<br>
1.5 MINIKUBE CLI ONLINE HELP</p>
<blockquote>
<p>minikube version<br>
minikube version: v0.31.0</p>
</blockquote>
<blockquote>
<p>minikube --help<br>
Minikube is a CLI tool that provisions and manages single-node Kubernetes clusters optimized for development workflows.</p>
</blockquote>
<p>Usage:<br>
minikube [command]</p>
<p>Available Commands:<br>
addons         Modify minikube's kubernetes addons<br>
cache          Add or delete an image from the local cache.<br>
completion     Outputs minikube shell completion for the given shell (bash or zsh)<br>
config         Modify minikube config<br>
dashboard      Access the kubernetes dashboard running within the minikube cluster<br>
delete         Deletes a local kubernetes cluster<br>
docker-env     Sets up docker env variables; similar to '$(docker-machine env)'<br>
help           Help about any command<br>
ip             Retrieves the IP address of the running cluster<br>
logs           Gets the logs of the running instance, used for debugging minikube, not user code<br>
mount          Mounts the specified directory into minikube<br>
profile        Profile sets the current minikube profile<br>
service        Gets the kubernetes URL(s) for the specified service in your local cluster<br>
ssh            Log into or run a command on a machine with SSH; similar to 'docker-machine ssh'<br>
ssh-key        Retrieve the ssh identity key path of the specified cluster<br>
start          Starts a local kubernetes cluster<br>
status         Gets the status of a local kubernetes cluster<br>
stop           Stops a running local kubernetes cluster<br>
tunnel         tunnel makes services of type LoadBalancer accessible on localhost<br>
update-check   Print current and latest version number<br>
update-context Verify the IP address of the running cluster in kubeconfig.<br>
version        Print the version of minikube</p>
<p>Flags:<br>
--alsologtostderr                  log to standard error as well as files<br>
-b, --bootstrapper string              The name of the cluster bootstrapper that will set up the kubernetes cluster. (default &quot;kubeadm&quot;)<br>
-h, --help                             help for minikube<br>
--log_backtrace_at traceLocation   when logging hits line file:N, emit a stack trace (default :0)<br>
--log_dir string                   If non-empty, write log files in this directory<br>
--logtostderr                      log to standard error instead of files<br>
-p, --profile string                   The name of the minikube VM being used.<br>
This can be modified to allow for multiple minikube instances to be run independently (default &quot;minikube&quot;)<br>
--stderrthreshold severity         logs at or above this threshold go to stderr (default 2)<br>
-v, --v Level                          log level for V logs<br>
--vmodule moduleSpec               comma-separated list of pattern=N settings for file-filtered logging</p>
<p>Use &quot;minikube [command] --help&quot; for more information about a command.</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Kafka 分析]]></title>
        <id>https://www.luoboyu.com/post/kafka-fen-xi</id>
        <link href="https://www.luoboyu.com/post/kafka-fen-xi">
        </link>
        <updated>2015-01-26T09:08:12.000Z</updated>
        <summary type="html"><![CDATA[<p>Kafka 作为一款基于磁盘存储的高吞吐消息中间件，常作为 log、event 等流式数据的通道，在流式计算领域也有丰富应用，下面简单分析其高吞吐、高性能的几点原因</p>
]]></summary>
        <content type="html"><![CDATA[<p>Kafka 作为一款基于磁盘存储的高吞吐消息中间件，常作为 log、event 等流式数据的通道，在流式计算领域也有丰富应用，下面简单分析其高吞吐、高性能的几点原因</p>
<!-- more -->
<h2 id="1-零拷贝">1、零拷贝</h2>
<p>普通的数据传输一般涉及 read、write 两个系统调用，而 kafka 的 broker 传递数据给消费者使用零拷贝的技术，底层使用了 sendfile 的系统调用，减少了用户态与内核态的上下文切换和数据拷贝的次数，read、write 两次系统调用涉及 4 次的上下文切换和 4 次的数据拷贝才能从一端到另一端，而 sendfile 系统调用只需要 2 次的上下文切换和 3 次的数据拷贝，减少了两次的上下文切换和一次拷贝动作，善用零拷贝可以优化基于磁盘的分布式系统的数据传输</p>
<h2 id="2-顺序写-page-cache">2、顺序写 + page cache</h2>
<p>普通磁盘的随机写性能较低，顺序写的性能则好很多，kafka 的存储模型就是一个 FIFO 的队列模型，不断地追加写文件，直到达到配置的大小限制（默认1GB）后进行翻滚，而当 kafka 的 partition 增多后，每个磁盘的随机写会增加，kafka 本身写入逻辑非常简单，使用普通的 java api，所以其完全依赖 linux 系统本身的 page cache，写到 page cache 后不是立刻写入磁盘，而要等待系统的 pdflush 线程进行刷盘操作，官方文档描述了 3 点使用 page cache 相对应用层缓存的优点：</p>
<ul>
<li>多次连续写入能批量汇聚成一次的物理写提高吞吐量</li>
<li>写入重排最小化磁头移动的次数，优化写入性能</li>
<li>自动使用系统的剩余内存</li>
</ul>
<h2 id="3-分区partition">3、分区（partition）</h2>
<p>partiton 是 topic 的子概念，一个 topic 可以分成多个 partition，partition 是 kafka 横向扩展和并行化的基础，每个 partition 都可以并行写入与读取，一般会预估数据的量级，选择合适的 partition 数量进行 topic 的创建，某种程度上而言，partition 越多意味着读写的吞吐量越大，当然不是绝对的，分区越多对于磁盘的顺序写影响越大，更容易产生随机写降低性能。关于分区基本上所有分布式（存储、计算）系统都有类似抽象，基本都是依托其作为水平扩展的基础</p>
<h2 id="4-reactor-网络模型">4、reactor 网络模型</h2>
<p>Kafka 的网络层使用 reactor 的线程模型，单个 acceptor 线程负责处理所有客户端的连接，建立连接后将 socket 的轮询分发给多个 processor 线程处理读写请求，processor 只负责数据的接收和发送，其后还有多个 handler 线程进行具体的逻辑操作，通过这样的异步线程模型，kafka 能够与成千上万的客户端交互而毫无压力</p>
]]></content>
    </entry>
</feed>